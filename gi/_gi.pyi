from typing import Callable, ClassVar
from collections.abc import Sequence

_API: object
_PyGObject_API: object

pygobject_version: tuple[int, int, int]

class GType:
    pytype: type
    fundamental: bool

    @classmethod
    def from_name(cls, name: str) -> GType: ...

    def is_a(self, other: GType) -> bool: ...

class TypeTag(type):
    ARRAY: ClassVar[int] = ...
    BOOLEAN: ClassVar[int] = ...
    DOUBLE: ClassVar[int] = ...
    ERROR: ClassVar[int] = ...
    FILENAME: ClassVar[int] = ...
    FLOAT: ClassVar[int] = ...
    GHASH: ClassVar[int] = ...
    GLIST: ClassVar[int] = ...
    GSLIST: ClassVar[int] = ...
    GTYPE: ClassVar[int] = ...
    INT16: ClassVar[int] = ...
    INT32: ClassVar[int] = ...
    INT64: ClassVar[int] = ...
    INT8: ClassVar[int] = ...
    INTERFACE: ClassVar[int] = ...
    UINT16: ClassVar[int] = ...
    UINT32: ClassVar[int] = ...
    UINT64: ClassVar[int] = ...
    UINT8: ClassVar[int] = ...
    UNICHAR: ClassVar[int] = ...
    UTF8: ClassVar[int] = ...
    VOID: ClassVar[int] = ...

class BaseInfo:
    __name__: str
    def get_name(self) -> str: ...

    def get_namespace(self) -> str: ...

    def get_g_type(self) -> GType: ...

class ConstantInfo(BaseInfo):
    def get_value(self) -> int: ...

class StructInfo(BaseInfo):

    def get_size(self) -> int: ...

class UnionInfo(BaseInfo):
    ...

class CallableInfo(BaseInfo):
    ...

class CallbackInfo(CallableInfo):
    ...

class VFuncInfo(CallableInfo):
    ...

class FunctionInfo(CallableInfo):
    def is_method(self) -> bool: ...

class RegisteredTypeInfo(BaseInfo):
    ...

class InterfaceInfo(BaseInfo):
    ...

class ObjectInfo(BaseInfo):
    ...

class EnumInfo(BaseInfo):
    def is_flags(self) -> bool: ...
    def get_methods(self) -> Sequence[BaseInfo]: ...

class Direction(type):
    IN: ClassVar[int] = ...
    INOUT: ClassVar[int] = ...
    OUT: ClassVar[int] = ...

class Struct:
    ...

class Boxed:
    ...

class Fundamental:
    pass

class CCallback:
    pass

class GInterface:
    pass

class Repository:
    @classmethod
    def get_default(cls) -> Repository: ...
    def get_loaded_namespaces(self) -> list[str]: ...
    def require(self, namespace: str, version: str, lazy: bool = False) -> None: ...
    def get_typelib_path(self, namespace: str) -> str: ...
    def get_version(self, namespace: str) -> str: ...
    def find_by_name(self, namespace: str, name: str) -> BaseInfo: ...
    def get_infos(self, namespace: str) -> Sequence[BaseInfo]: ...
    def is_registered(self, namespace: str, version: str | None = None) -> bool: ...
    def enumerate_versions(self, namespace: str) -> Sequence[str]: ...
    def get_immediate_dependencies(self, namespace: str) -> Sequence[str]: ...

class RepositoryError(Exception):
    ...

class PyGIWarning(Warning):
    ...

class PyGIDeprecationWarning(PyGIWarning):
    ...

class GEnum:
    __new__: ClassVar[Callable] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _hashable_values_: ClassVar[list] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _unhashable_values_map_: ClassVar[dict] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    __gtype__: ClassVar[GType] = ...
    value_name: str
    value_nick: str

class GObject:
    ...

def enum_add(module, name, g_type, enum_info): ...

def flags_add(module, name, g_type, flags_info): ...

def register_foreign(): ...

def require_foreign(namespace: str, symbol: str | None = None) -> None: ...
G_MAXDOUBLE: float
G_MAXFLOAT: float
G_MAXINT: int
G_MAXLONG: int
G_MAXOFFSET: int
G_MAXSHORT: int
G_MAXSIZE: int
G_MAXSSIZE: int
G_MAXUINT: int
G_MAXULONG: int
G_MAXUSHORT: int
G_MINDOUBLE: float
G_MINFLOAT: float
G_MININT: int
G_MINLONG: int
G_MINOFFSET: int
G_MINSHORT: int
G_MINSSIZE: int
PARAM_READWRITE: int
SIGNAL_RUN_FIRST: int
TYPE_GSTRING: GType
TYPE_INVALID: GType
